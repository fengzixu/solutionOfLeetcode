#include <iostream>
#include <vector>
using namespace std;

// 从排序数组中删除重复项
/* 思路：
   题干中有一个比较关键的信息，就是「已经排序」的数组。在这种情况下，首先不用考虑按顺序输出的问题。另外一个不用考虑在去重的过程中，重复的元素
   没有挨在一起导致很难处理的问题。
   所以，我们现在要解决的问题，就是按照顺序，将不重复的元素从数组的开头开始排放，并且最终返回一个「不重复元素的数量」，使得 Test 可以输出数组中不重复的元素。
   设置两个 cursor，一个 i，一个 j。i 作为已经排序且不重复子数组的尾部元素+1的位置，即插入位置。而 j 则作为比较元素的位置。for 循环从下标1开始，因为下标为0的元素肯定是在最终的
   数组内的，相当于将下标0的元素作为了比较的基准元素。i，j 初始值都为1。在循环的过程中需要比较两个元素：nums[j] nums[j-1], 如果相同那么证明nums[j]并不需要移动位置。然后，j+1
   向前移动一个位置取下一个待比较元素，而 i 则不移动。如果 nums[j] nums[j-1]不相同，那么证明 num[j] 需要移动到 i 所标识隔离的子数组中，
   所以将 nums[i]=nums[j] 且 i+1。之所以不用交换变量的原因是因为，我们只需要将不重复元素挑选出来即可，下标>=j 的元素才是我们需要考虑的，>=i && < j 的元素，都是已经重复的。且在比较
   的过程中是需要相邻元素之间进行排序的。
   
*/

class Solution
{
  public:
    int removeDuplicates(vector<int> &nums)
    {
        if (nums.size() == 0)
        {
            return 0;
        }

        int N = 1;
        for (int i = 1, j = 1; j < nums.size();)
        {
            if (nums[j] == nums[j - 1])
            {
                j++;
            }
            else
            {
                nums[i] = nums[j];
                i++;
                j++;
                N++;
            }
        }

        return N;
    }
};